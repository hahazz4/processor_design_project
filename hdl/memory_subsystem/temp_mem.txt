                    Address ORG 0
08800002                    0           ldi R1, 2 ; R1 = 2
08080000                                ldi R0, 0(R1) ; R0 = 2
01000068                                ld R2, $68 ; R2 = ($68) = $55
0913FFFC                                ldi R2, -4(R2) ; R2 = $51
00900001                                ld R1, 1(R2) ; R1 = ($52) = $26
09800069                                ldi R3, $69 ; R3 = $69
99980004                                brmi R3, 4 ; continue with the next instruction (will not branch)
09980002                                ldi R3, 2(R3) ; R3 = $6B
039BFFFD                                ld R7, -3(R3) ; R7 = ($6B - 3) = $55
D0000000                                nop
9B900002                                brpl R7, 2 ; continue with the instruction at “target” (will branch)
00000000                                ldi R2, 5(R0) ; this instruction will not execute
09880002                                ldi R3, 2(R1) ; this instruction will not execute
19918000                    target      add R3, R2, R3 ; R3 = $BC
63B80002                                addi R7, R7, 2 ; R7 = $57
8BB80000                                neg R7, R7 ; R7 = $FFFFFFA9
93B80000                                not R7, R7 ; R7 = $56
6BB8000F                                andi R7, R7, $0F ; R7 = 6
50880000                                ror R1, R1, R0 ; R1 = $80000009
7388001C                                ori R7, R1, $1C ; R7 = $8000001D
43B80000                                shra R7, R7, R0 ; R7 = $E0000007
39180000                                shr R2, R3, R0 ; R2 = $2F
11000052                                st $52, R2 ; ($52) = $2F new value in memory with address $52
59100000                                rol R2, R2, R0 ; R2 = $BC
31180000                                or R2, R3, R0 ; R2 = $BE
28908000                                and R1, R2, R1 ; R1 = $8
11880060                                st $60(R1), R3 ; ($68) = $BC new value in memory with address $68
21918000                                sub R3, R2, R3 ; R3 = 2
48900000                                shl R1, R2, R0 ; R1 = $2F8
0A000006                                ldi R4, 6 ; R4 = 6
0A800032                                ldi R5, $32 ; R5 = $32
7AA00000                                mul R5, R4 ; HI = 0; LO = $12C
C3800000                                mfhi R7 ; R7 = 0
CB000000                                mflo R6 ; R6 = $12C
82A00000                                div R5, R4 ; HI = 2, LO = 8
0C23FFFF                                ldi R8, -1(R4) ; R8 = 5 setting up argument registers
0CABFFED                                ldi R9, -19(R5) ; R9 = $1F R8, R9, R10, and R11
0D300000                                ldi R10, 0(R6) ; R10 = $12C
0DB80000                                ldi R11, 0(R7) ; R11 = 0
AD000000                                jal R10 ; address of subroutine subA in R10 - return address in R15
D8000000                    $28         halt ; upon return, the program halts

                            $12C subA   ORG $12C ; procedure subA
1EC50000                                add R13, R8, R10 ; R12 and R13 are return value registers
264D8000                                sub R12, R9, R11 ; R13 = $131, R12 = $1F
26EE0000                                sub R13, R13, R12 ; R13 = $112
A7800000                                jr R15 ; return from procedure